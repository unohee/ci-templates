#!/bin/bash
# Universal Python pre-commit hook with Fake Data Detection
# Configurable via environment variables
#
# Installation:
#   cp hooks/pre-commit .git/hooks/
#   chmod +x .git/hooks/pre-commit
#
# Bypass (not recommended):
#   git commit --no-verify

set -e

echo "üîç Pre-commit code quality check..."

# =============================================================================
# Configuration (overridable via env vars)
# =============================================================================
MAX_LINES=${MAX_LINES:-800}
SRC_PATH=${SRC_PATH:-src/}
ENABLE_FAKE_DATA_CHECK=${ENABLE_FAKE_DATA_CHECK:-true}
FEATURE_PATTERNS=${FEATURE_PATTERNS:-"feature|program|arbitrage"}

# =============================================================================
# Virtual environment detection
# =============================================================================
if [ -n "$VIRTUAL_ENV" ]; then
    echo "‚úÖ Virtual environment already active."
elif [ -n "$PROJECT_VENV_PATH" ]; then
    source "$PROJECT_VENV_PATH"/bin/activate
elif [ -f ~/RTX_ENV/bin/activate ]; then
    source ~/RTX_ENV/bin/activate
elif [ -f .venv/bin/activate ]; then
    source .venv/bin/activate
elif [ -f venv/bin/activate ]; then
    source venv/bin/activate
else
    echo "‚ö†Ô∏è No virtual environment found. Set PROJECT_VENV_PATH or create venv."
    exit 1
fi

# =============================================================================
# Get changed Python files
# =============================================================================
CHANGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.py$' || true)

if [ -z "$CHANGED_FILES" ]; then
    echo "‚úÖ No Python files changed."
    exit 0
fi

echo "üìù Changed files: $(echo $CHANGED_FILES | wc -w) files"

FAILED=0

# =============================================================================
# 1. Fake Data Detection (CRITICAL)
# =============================================================================
if [ "$ENABLE_FAKE_DATA_CHECK" = "true" ]; then
    echo ""
    echo "üî¥ [1/5] Fake Data Detection..."

    FAKE_DATA_FOUND=0
    for file in $CHANGED_FILES; do
        if [ -f "$file" ]; then
            # Skip test files
            if echo "$file" | grep -q "test_"; then
                continue
            fi

            # Check for np.random in feature generation code
            if grep -n "np\.random\.\(rand\|randn\|uniform\|normal\|random\)" "$file" 2>/dev/null | \
               grep -v "#" | grep -v "seed" | grep -v "random_state" | grep -v "shuffle"; then

                # Check if it's used in feature variables
                if grep -E "($FEATURE_PATTERNS).*np\.random" "$file" 2>/dev/null | grep -v "#"; then
                    echo "   ‚ùå $file: np.random in feature code (fake data)"
                    grep -n "np\.random" "$file" | head -3
                    FAKE_DATA_FOUND=1
                    FAILED=1
                fi
            fi
        fi
    done

    # Run dedicated detector if available
    if [ -f scripts/quality/fake_data_detector.py ] || [ -f scripts/fake_data_detector.py ]; then
        DETECTOR_PATH=""
        if [ -f scripts/quality/fake_data_detector.py ]; then
            DETECTOR_PATH="scripts/quality/fake_data_detector.py"
        else
            DETECTOR_PATH="scripts/fake_data_detector.py"
        fi

        for file in $CHANGED_FILES; do
            if [ -f "$file" ] && ! echo "$file" | grep -q "test_"; then
                result=$(python "$DETECTOR_PATH" "$file" --ci 2>/dev/null || true)
                if echo "$result" | grep -q "::error"; then
                    echo "$result"
                    FAKE_DATA_FOUND=1
                    FAILED=1
                fi
            fi
        done
    fi

    if [ $FAKE_DATA_FOUND -eq 0 ]; then
        echo "   ‚úÖ No fake data patterns found"
    fi
else
    echo ""
    echo "‚è≠Ô∏è  [1/5] Fake Data Detection (SKIPPED)"
fi

# =============================================================================
# 2. Magic Number Check (WARNING)
# =============================================================================
echo ""
echo "üü° [2/5] Magic Number Check..."

MAGIC_FOUND=0
for file in $CHANGED_FILES; do
    if [ -f "$file" ]; then
        # Feature variables with hardcoded ratios (0.6 * something)
        if grep -En "^\s*($FEATURE_PATTERNS)\w*\s*=\s*[0-9]+\.[0-9]+\s*\*" "$file" 2>/dev/null | grep -v "#"; then
            echo "   ‚ö†Ô∏è  $file: Magic number in feature code"
            MAGIC_FOUND=1
        fi
    fi
done

if [ $MAGIC_FOUND -eq 0 ]; then
    echo "   ‚úÖ No suspicious magic numbers"
else
    echo "   üí° Consider using constants or config files"
fi

# =============================================================================
# 3. Black formatting
# =============================================================================
echo ""
echo "üîµ [3/5] Black Formatting..."

if command -v black &> /dev/null; then
    if ! black --quiet $CHANGED_FILES 2>/dev/null; then
        echo "   ‚ö†Ô∏è  Black formatting applied"
    fi
    echo "   ‚úÖ Formatting complete"
else
    echo "   ‚ö†Ô∏è  black not found, skipping"
fi

# =============================================================================
# 4. Ruff linting
# =============================================================================
echo ""
echo "üîµ [4/5] Ruff Linting..."

if command -v ruff &> /dev/null; then
    ruff check --fix $CHANGED_FILES 2>/dev/null || true

    # Syntax check (required)
    if ! ruff check --select E9,F63,F7,F82 $CHANGED_FILES 2>/dev/null; then
        echo "   ‚ùå Critical syntax errors found"
        FAILED=1
    else
        echo "   ‚úÖ Lint complete"
    fi
else
    echo "   ‚ö†Ô∏è  ruff not found, skipping"
fi

# Python compile check
python -m compileall -q $CHANGED_FILES 2>/dev/null || {
    echo "   ‚ùå Python compile errors"
    FAILED=1
}

# =============================================================================
# 5. LOC gate
# =============================================================================
echo ""
echo "üîµ [5/5] LOC Gate (max ${MAX_LINES} lines)..."

for file in $CHANGED_FILES; do
    # Skip trash/archive
    if [[ "$file" == trash/* ]] || [[ "$file" == archive/* ]]; then
        continue
    fi

    if [ -f "$file" ]; then
        lines=$(wc -l < "$file")
        if [ "$lines" -gt "$MAX_LINES" ]; then
            echo "   ‚ùå $file: $lines lines (exceeds $MAX_LINES)"
            FAILED=1
        fi
    fi
done

if [ $FAILED -eq 0 ]; then
    echo "   ‚úÖ All files under ${MAX_LINES} lines"
fi

# =============================================================================
# Stage auto-fixed files
# =============================================================================
git add $CHANGED_FILES 2>/dev/null || true

# =============================================================================
# Result
# =============================================================================
echo ""
echo "=========================================="

if [ $FAILED -eq 1 ]; then
    echo "‚ùå Pre-commit FAILED"
    echo ""
    echo "Solutions:"
    echo "  - np.random in features ‚Üí Use real API data"
    echo "  - Magic numbers ‚Üí Define as constants"
    echo "  - LOC > ${MAX_LINES} ‚Üí Split into modules"
    echo ""
    echo "Bypass (not recommended): git commit --no-verify"
    exit 1
else
    echo "‚úÖ Pre-commit PASSED!"
    exit 0
fi
